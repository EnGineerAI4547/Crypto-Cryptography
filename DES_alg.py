"""
Eric Gonzalez 
Z22312551
Assignment 02 
Mehrdad Nojoumian 
CIS5371/CIS 4634: Practical Aspects of Modern Cryptography 
"""




import os
import re
import sys
import secrets








def exit():
    print("Exiting program. Goodbye!")
    sys.exit(0)



#Define a function explaining what DES, double DES and triple DES are

def des_explanation():
    print("DES stands for Data Encryption Standard. It is a symmetric-key algorithm used for encryption and decryption of electronic data.")
           
    print("DES operates on 64-bit blocks of data at a time and uses a 64-bit key to encrypt and decrypt the data.")
    print("Double DES is the use of two successive applications of DES on a plaintext message.")
    print("Double DES uses a 112-bit key (two 56-bit keys concatenated together) to encrypt and decrypt the data.")
    print("Triple DES (3DES) is the use of three successive applications of DES on a plaintext message.")
    print("Triple DES can be implemented in two different modes: 1) EDE (Encrypt, Decrypt, Encrypt) or 2)EEE (Encrypt, Encrypt, Encrypt).")
    print("For this program EEE will be used. Triple DES uses a 168-bit key (three 56-bit keys concatenated together) to encrypt and decrypt the data.")
    while True:
        choice = input("\n\n\nEnter 'r' to read again, 'm' to return to the menu, or 'x' to exit the program: ")
        if choice == 'r':
            des_explanation()
        elif choice == 'm':
            menu()
        elif choice == 'x':
            exit()
        else:
            print("Invalid choice. Please try again.")


#Define a function that explains what a key is and how it is used in DES
def key_explanation():
    print("A key is a sequence of bits used by the DES algorithm to encrypt and decrypt data.")
    print("For the standard DES algorithm, the key is 56 bits long.")
    print("Double DES and triple DES use multiple keys to provide additional security.")
    print("During encryption, the key is used to generate 16 subkeys that are used in the Feistel network.")
    print("Each subkey is generated by applying a permutation and a key schedule to the previous subkey.")
    print("The subkeys are used to encrypt and decrypt the data in a series of Feistel rounds.")
    print("The key is also used to initialize the state of the pseudorandom number generator in CTR mode.")
    print("It is important to choose a strong and unique key to ensure the security of the encrypted data.")
    print("A strong key is a key that is difficult to guess or crack.")
    print("A unique key is a key that is not used for any other purpose.")
    print("A key should be at least 8 characters long and should contain a mix of upper and lower case letters, numbers and special characters.")
    print("A key should not be a word or phrase that can be found in a dictionary.")
    print("This is why for sake of this program a key will be generated for you.")
    while True:
        choice = input("\n\n\nEnter 'r' to read again, 'm' to return to the menu, or 'x' to exit the program: ")
        if choice == 'r':
            key_explanation()
        elif choice == 'm':
            menu()
        elif choice == 'x':
            exit()
        else:
            print("Invalid choice. Please try again.")


#Define a function that explains what decryption and encryption is and how it is used in DES
def des_encryption_decryption_explanation():
    print("Encryption is the process of transforming data so that it is unreadable by anyone who does not have the secret key to decode it.")
    print("Decryption is the process of transforming encrypted data back into its original, readable form using the secret key.")
    print("In DES, the plaintext (the original message) is divided into blocks of 64 bits, which are then processed through multiple rounds of encryption using a secret key.")
    print("The encrypted ciphertext is then transmitted securely, and the recipient uses the same secret key to decrypt the ciphertext back into the original plaintext.")
    while True:
        choice = input("\n\n\nEnter 'r' to read again, 'm' to return to the menu, or 'x' to exit the program: ")
        if choice == 'r':
            des_encryption_decryption_explanation()
        elif choice == 'm':
            menu()
        elif choice == 'x':
            exit()
        else:
            print("Invalid choice. Please try again.")


#Define a function that explains the modes of operations 
def des_modes_explanation():
    print("The Data Encryption Standard (DES) supports several modes of operation, which determine how the encryption is performed. The following are the modes of operation supported by DES:\n")
    print("1. Electronic Codebook (ECB) mode: In this mode, each block of plaintext is encrypted separately using the same key.") 
    print("This can result in patterns in the ciphertext if the same plaintext blocks are encrypted with the same key.")
    print("2. Cipher Block Chaining (CBC) mode: In this mode, each plaintext block is XORed with the previous ciphertext block before encryption.")
    print("This makes it harder to detect patterns in the ciphertext, but requires an initialization vector (IV) to be chosen randomly and kept secret.")
    print("3. Cipher Feedback (CFB) mode: In this mode, the output of the encryption function is XORed with the plaintext to produce the ciphertext.") 
    print("The output of the encryption function is also fed back into the encryption function to generate the next block of ciphertext.")
    print("4. Output Feedback (OFB) mode: In this mode, the encryption function is applied to an IV to generate a keystream, which is XORed with the plaintext to produce the ciphertext.")
    print("The keystream is also fed back into the encryption function to generate the next keystream.")
    print("5. Counter (CTR) mode: In this mode, a counter is encrypted to generate a keystream, which is XORed with the plaintext to produce the ciphertext.") 
    print("The counter is incremented for each block of plaintext.\n")
    while True:
        choice = input("\n\n\nEnter 'r' to read again, 'm' to return to the menu, or 'x' to exit the program: ")
        if choice == 'r':
            des_modes_explanation()
        elif choice == 'm':
            menu()
        elif choice == 'x':
            exit()
        else:
            print("Invalid choice. Please try again.")





#Define a function that asks a user what they want to learn about Des, double DES or triple DES, modes of operation or keys via a menu
"""The User should be able to choose what they want to learn about DES, double DES or triple DES, modes of operation or keys via a menu "
" At any point the user should be able to choose to go back to the menu, exit the program or skip the explanation and go straight to encrypting/decrypting"""
def menu():
    while True:
        print("\n\n\nPlease choose an option by selecting the corresponding number:")
        print("The rules of this program are as follows:")
        print("You can only choose one of the following menu options at a time. \n")
        print("You can choose to learn about DES, double DES or triple DES, modes of operation or keys.")
        print("Or you can choose to skip out on education and instead encrypt/decrypt a message of your choice. Have fun!\n")
        print("1. Learn about DES, double DES or triple DES")
        print("2. Learn about modes of operation")
        print("3. Learn about keys")
        print("4. Encrypt/Decrypt")
        print("5. Exit")
        choice = input("> ")
        
        if choice == "1":
            des_explanation()
        elif choice == "2":
            des_modes_explanation()
        elif choice == "3":
            key_explanation()
        elif choice == "4":
            run_des()
        elif choice == "5":
            break
        else:
            print("Invalid choice. Please choose again.")


 #Define a function that asks user if they want to skip the explanation and go straight encrypting/decrypting
def skip_explanation():
    # Ask user if they want to skip the explanation
    skip = input("Do you want to skip the explanation and go straight to encrypting/decrypting? (Y/N)")

    # If the user wants to skip, return True
    if skip.lower() == 'y':
        return True

    # Otherwise, return False
    return False


#Define a function that gets a counter value from the user

def increment_counter(counter):
    """
    Increment the 64-bit counter by 1.

    Args:
        counter (bytes): The 64-bit counter represented as a byte string.

    Returns:
        bytes: The 64-bit counter incremented by 1 represented as a byte string.
    """
    # Convert the counter to an integer
    counter_int = int.from_bytes(counter, 'big')

    # Increment the counter by 1
    counter_int += 1

    # Convert the counter back to a byte string
    counter_bytes = counter_int.to_bytes(8, 'big')

    return counter_bytes



# Define a function that converts ASCII to binary

def ascii_to_binary(ascii_str):
    """
    Converts an ASCII string to binary string.

    Args:
        ascii_str (str): The ASCII string to convert.

    Returns:
        str: The binary string.
    """
    binary_str = ''.join(format(ord(char), '08b') for char in ascii_str)
    return binary_str

#Define a function to get the plaintext from the user

def get_padded_plaintext():
    """
    Prompts the user for plaintext, converts it to a bytearray, and pads it with PKCS#7 if necessary.

    Returns:
    bytearray: The padded plaintext as a bytearray.
    """

    # Define a regular expression to match valid input
    pattern = r'^[a-zA-Z0-9 !@#$%^&*()_+\-={}\[\]:;"\'<>,.?/\\\n]+$'

    while True:
        # Prompt the user for input
        plaintext = input("Enter plaintext: ")

        # Check if input matches the pattern
        if re.match(pattern, plaintext):
            plaintext_bytes = bytearray(plaintext, 'utf-8')

            # Check if the plaintext length is a multiple of 8 bytes
            if len(plaintext_bytes) % 8 != 0:
                # Calculate the number of bytes needed to pad the plaintext
                padding = 8 - len(plaintext_bytes) % 8

                # Add the padding to the plaintext
                plaintext_bytes += bytearray([padding] * padding)

            return plaintext_bytes

        # Check if input is empty or only whitespace characters
        elif not plaintext.strip():
            print("Error: Input cannot be empty.")
            
        # Check if input contains non-ASCII characters
        elif not all(ord(c) < 128 for c in plaintext):
            print("Error: Input must contain only ASCII characters.")
            
        else:
            print("Invalid input. Please enter alphanumeric characters or symbols only.")




#Define a function that gets the ciphertext from the user

def get_ciphertext():
    """
    Gets ciphertext input from the user, ensures that it is in hexadecimal format and is a multiple of 8 bytes long, and returns the value as a bytearray.
    """

    while True:
        # Prompt the user for input
        ciphertext_str = input("Enter ciphertext (in hexadecimal format and a multiple of 8 bytes long): ")

        # Remove any whitespace from the input
        ciphertext_str = ciphertext_str.replace(" ", "")

        try:
            # Convert the input to bytearray using the fromhex() method
            ciphertext_bytearray = bytearray.fromhex(ciphertext_str)

            # Check if the input is a multiple of 8 bytes long
            if len(ciphertext_bytearray) % 8 != 0:
                raise ValueError("Invalid input: ciphertext must be a multiple of 8 bytes long.")

            # Return the ciphertext as a bytearray
            return ciphertext_bytearray

        except ValueError as e:
            print(str(e))
            continue





#Define a function to get the mode from the user 
def get_mode():
    """
    Gets the encryption mode input from the user, ensures that it is a valid mode, and returns the value as a string.
    """

    print("Valid modes: ECB, CBC, CFB, OFB, CTR")
    mode = input("Enter encryption mode (ECB, CBC, CFB, OFB, CTR): ")
    if mode not in ["ECB", "CBC", "CFB", "OFB", "CTR"]:
        print("Error: Invalid mode entered. Please try again.")
        return get_mode()
    return mode




#Define a function that gets the IV to be used in CBC, CFB, OFB and CTR modes
def get_iv():
    """
    Prompts the user to input an initialization vector (IV) in hexadecimal format,
    and validates the input to ensure it is a valid hexadecimal string.
    
    Returns:
    A bytearray representation of the IV.
    """
    print("\n\n\nAn initialization vector (IV) is a random or pseudorandom value used in cryptographic algorithms")
    print("to ensure that each message encrypted with the same key is unique. The IV should be a random value")
    print("and should never be reused with the same key.")
    print("Please enter an IV in hexadecimal format (0-9, a-f, A-F) of length 16 characters (64 bits):")
    iv_hex = input("IV: ")
    # Use regular expression to validate input
    pattern = re.compile(r'^[0-9a-fA-F]{16}$')
    if not pattern.match(iv_hex):
        print("Error: Input must be in hexadecimal format (0-9, a-f, A-F) and must be exactly 16 characters (64 bits)")
        return get_iv()
    # Convert the hexadecimal string to a bytearray
    iv = bytearray.fromhex(iv_hex)
    return iv




#Define a function to get the counter from the user
def get_counter():
    """
    Gets the counter input from the user, ensures that it is a valid integer, and returns the value as an integer.
    """
    counter = input("Enter counter value (must be a positive integer): ")
    if not counter.isdigit() or int(counter) <= 0:
        print("Error: Input must be a positive integer")
        return get_counter()
    return int(counter)



#Define a function that asks the users if they want to use single, double or triple DES and converts the answer to an integer

def get_des_type():
    while True:
        des_type = input("Do you want to use single, double, or triple DES? ")
        if des_type.lower() == "single":
            return 1
        elif des_type.lower() == "double":
            return 2
        elif des_type.lower() == "triple":
            return 3
        else:
            print("Invalid input. Please enter 'single', 'double', or 'triple'.")





def generate_master_key(des_type):
    # Determine the key size and number of keys based on the DES type
    if des_type == 1:
        key_size = 8  # 64 bits
        num_keys = 1
    elif des_type == 2:
        key_size = 16  # 128 bits
        num_keys = 2
    elif des_type == 3:
        key_size = 24  # 192 bits
        num_keys = 3
    else:
        # Invalid DES type
        print("Invalid DES type entered.")
        return None
    
    # Explain the relationship between byte size and hexadecimal
    print(f"\nThe key size for DES{des_type} is {int(key_size/num_keys)} byte(s) or ({key_size*8} bits).")
    print(f"For DES{des_type}, there will be {num_keys} key(s).")
    print("In hexadecimal format, each byte is represented by two characters (0-9, a-f) with no spaces.")
    print(f"So for a key {int(key_size/num_keys)} byte(s), each key should be {int(key_size/num_keys)*2} characters long in hexadecimal with no spaces.")
    
    # Ask the user if they want to enter their own master key or generate a random one
    while True:
        choice = input("Do you want to enter your own master key or generate a random one? (Enter '1' for own key or '2' for random key): ")
        if choice == '1':
            # Get the master key(s) from the user and pad/truncate them to the appropriate size
            keys = []
            for i in range(num_keys):
                while True:
                    key = input(f"Enter the {int(key_size/num_keys)}-byte or '{int(key_size/num_keys)*2} character' key {i+1} in hexadecimal format: ")
                    try:
                        key = bytearray.fromhex(key)[:key_size//num_keys]
                        keys.append(key)
                        break
                    except ValueError:
                        print("Invalid input. Please enter a valid hexadecimal string.")
                        continue
            break
        elif choice == '2':
            # Generate random master keys
            keys = [bytearray(secrets.token_bytes(key_size//num_keys)) for i in range(num_keys)]
            for i, key in enumerate(keys):
                print(f"The randomly generated {int(key_size/num_keys)}-byte key {i+1} is: {key.hex()}")
            break
        else:
            print("Invalid choice. Please enter '1' to enter your own master key or '2' to generate a random key.")
    
    # Return the master key(s)
    if num_keys == 1:
        return keys[0]
    elif num_keys == 2:
        return keys[0], keys[1]
    else:
        return keys[0], keys[1], keys[2]






#Define a function that converts a byte block into a binary string


def byte_to_binary(byte_block):
    """
    Convert a byte block into a binary string.

    Args:
        byte_block (bytes): The byte block to convert.

    Returns:
        str: The binary string obtained from the byte block.
    """
    binary_block = ''.join(format(byte, '08b') for byte in byte_block)
    return binary_block





#Define a function that applies the initial permutation to a 64-bit block of data

def initial_permutation(block):
    """
    Apply the initial permutation to a 64-bit block of data.

    Args:
        block (bytearray): The 64-bit binary block.

    Returns:
        bytearray: The 64-bit binary block obtained after applying the initial permutation.
    """
    ip_table = [58, 50, 42, 34, 26, 18, 10, 2,
                60, 52, 44, 36, 28, 20, 12, 4,
                62, 54, 46, 38, 30, 22, 14, 6,
                64, 56, 48, 40, 32, 24, 16, 8,
                57, 49, 41, 33, 25, 17, 9, 1,
                59, 51, 43, 35, 27, 19, 11, 3,
                61, 53, 45, 37, 29, 21, 13, 5,
                63, 55, 47, 39, 31, 23, 15, 7]

    # Ensure the input block is 64 bits
    if len(block) != 8:
        raise ValueError("The block must be 64 bits long.")

    # Apply the initial permutation
    ip_block = bytearray(8)
    for i, index in enumerate(ip_table):
        byte_index = (index - 1) // 8
        bit_index = (index - 1) % 8
        ip_block[i // 8] |= ((block[byte_index] >> bit_index) & 1) << (7 - i % 8)

    return ip_block


#Deine a function that applies the inverse permutation to the 64-bit block

def inverse_permutation(block):
    """
    Apply the inverse permutation to the 64-bit block.

    Args:
        block (bytearray): The 64-bit binary block.

    Returns:
        bytearray: The 64-bit binary block obtained after applying the inverse permutation.
    """
    # The inverse permutation table for DES
    inverse_table = [40, 8, 48, 16, 56, 24, 64, 32,
                     39, 7, 47, 15, 55, 23, 63, 31,
                     38, 6, 46, 14, 54, 22, 62, 30,
                     37, 5, 45, 13, 53, 21, 61, 29,
                     36, 4, 44, 12, 52, 20, 60, 28,
                     35, 3, 43, 11, 51, 19, 59, 27,
                     34, 2, 42, 10, 50, 18, 58, 26,
                     33, 1, 41, 9, 49, 17, 57, 25]

    # Ensure the input block is 64 bits
    if len(block) != 8:
        raise ValueError("The block must be 64 bits long.")

    # Apply the inverse permutation
    inverse_block = bytearray(len(block))
    for i, index in enumerate(inverse_table):
        # Calculate the byte and bit indexes
        byte_index = (index - 1) // 8
        bit_index = (index - 1) % 8

        # Get the bit from the input block
        bit = (block[byte_index] >> (7 - bit_index)) & 0x01

        # Set the bit in the output block
        inverse_block[i // 8] |= (bit << (7 - (i % 8)))

    return inverse_block


#Define the PC-1 permutation table for DES key generation

def pc1_permutation(key):
    """
    Apply the PC-1 permutation to the 64-bit key.

    Args:
        key (bytes): The 64-bit binary key.

    Returns:
        bytearray: The 56-bit binary key obtained after applying the PC-1 permutation.
    """
    pc1_table = [
        57, 49, 41, 33, 25, 17, 9, 1,
        58, 50, 42, 34, 26, 18, 10, 2,
        59, 51, 43, 35, 27, 19, 11, 3,
        60, 52, 44, 36, 63, 55, 47, 39,
        31, 23, 15, 7, 62, 54, 46, 38,
        30, 22, 14, 6, 61, 53, 45, 37,
        29, 21, 13, 5, 28, 20, 12, 4
    ]


    # Ensure the input key is 64 bits
    if len(key) != 8:
        raise ValueError("The key must be 8 bytes long.")

    # Convert the key to a binary string
    binary_key = "".join(format(byte, "08b") for byte in key)

    # Apply the PC-1 permutation
    pc1_key = bytearray(8)
    for i, index in enumerate(pc1_table):
        byte_index = (index - 1) // 8
        bit_index = index % 8
        pc1_key[byte_index] |= int(binary_key[i]) << (7 - bit_index)


    return pc1_key[:-1]







#Define the PC-2 permutation function to be used in the key schedule

def pc2_permutation(key):
    """
    Apply the PC-2 permutation to the 56-bit key.

    Args:
        key (bytearray): The 56-bit binary key.

    Returns:
        bytearray: The 48-bit binary key obtained after applying the PC-2 permutation.
    """
    if len(key) != 7:
        raise ValueError("The key must be 7 bytes long.")

    pc2_table = [[13, 16, 10, 23, 0, 4, 2, 27],
                 [14, 5, 20, 9, 22, 18, 11, 3],
                 [25, 7, 15, 6, 26, 19, 12, 1],
                 [40, 51, 30, 36, 46, 54, 29, 39],
                 [50, 44, 32, 47, 43, 48, 38, 55],
                 [33, 52, 45, 41, 49, 35, 28, 31]]

    # Convert the key to a binary string
    binary_key = "".join(format(byte, "08b") for byte in key)

    # Apply the PC-2 permutation
    permuted_key = bytearray(6)
    for i in range(48):
        row = pc2_table[i // 8]
        col = row[i % 8]
        bit_value = int(binary_key[col])
        byte_index = i // 8
        bit_index = i % 8
        permuted_key[byte_index] |= bit_value << (7 - bit_index)

    return permuted_key









#Define a function to be used to permute the 32-bit right half of the block during the feistel function and after the s-boxes
def p_box_permutation(block):
    """
    Apply the P-box permutation to the 32-bit block.

    Args:
        block (bytearray): The 32-bit binary block.

    Returns:
        bytearray: The 32-bit binary block obtained after applying the P-box permutation.
    """
    p_box_table = [16, 7, 20, 21, 29, 12, 28, 17,
                   1, 15, 23, 26, 5, 18, 31, 10,
                   2, 8, 24, 14, 32, 27, 3, 9,
                   19, 13, 30, 6, 22, 11, 4, 25]

    # Ensure the input block is 32 bits
    if len(block) != 4:
        raise ValueError("The block must be 4 bytes long.")

    # Convert the input block to a binary string
    binary_block = ""
    for byte in block:
        binary_block += format(byte, "08b")

    # Apply the P-box permutation
    p_box_block = bytearray(b'\x00\x00\x00\x00')
    for index in p_box_table:
        byte_index = (index - 1) // 8
        bit_index = (index - 1) % 8
        p_box_block[byte_index] |= (int(binary_block[index-1]) << (7-bit_index))

    return p_box_block



#Define the function to be used to split a block of bytes into two halves   
def split_block(block):
    """Split a block of bytes into two halves."""
    # Calculate the block size and half size
    block_size = len(block)
    half_size = block_size // 2
    
    # Split the block into two halves
    left_half = bytearray(block[:half_size])
    right_half = bytearray(block[half_size:])
    
    return left_half, right_half



# Define a function to be used to swap the left and right halves of a block

def swap_halves(block):
    """
    Swaps the left and right halves of a block.

    Args:
        block (bytearray): The block to swap.

    Returns:
        bytearray: The block with its left and right halves swapped.
    """
    block_size = len(block)
    half_size = block_size // 2
    left_half = block[:half_size]
    right_half = block[half_size:]
    return right_half + left_half





# Define the left shift function to be used in the key schedule
def left_shift_bits(block, shift_amount):
    """
    Shifts a bytearray of bits to the left by a specified amount.
    
    Args:
        block (bytearray): The bytearray of bits to shift.
        shift_amount (int): Amount to shift the bits.
        
    Returns:
        A bytearray of shifted bits.
    """
    # Convert the bytearray to a list of bits
    block_list = []
    for byte in block:
        block_list.extend([(byte >> i) & 1 for i in range(7, -1, -1)])
    
    # Perform the left shift
    shifted_list = block_list[shift_amount:] + block_list[:shift_amount]
    
    # Convert the shifted list back to a bytearray
    shifted_block = bytearray()
    for i in range(0, len(shifted_list), 8):
        shifted_byte = 0
        for j in range(8):
            shifted_byte |= shifted_list[i+j] << (7-j)
        shifted_block.append(shifted_byte)
    
    return shifted_block


# Define the function to be used to perform the expansion permutation on the 32-bit right half of the block

def expansion_permutation(block):
    """
    Perform expansion permutation on a 32-bit block to get a 48-bit block
    
    Args:
        block (bytearray): The 32-bit block to permute.
    
    Returns:
        A bytearray containing the 48-bit block after the expansion permutation.
    """
    # Expand the 32-bit block to 48 bits using the expansion permutation
    expansion_table = [
        31,  0,  1,  2,  3,  4,
         3,  4,  5,  6,  7,  8,
         7,  8,  9, 10, 11, 12,
        11, 12, 13, 14, 15, 16,
        15, 16, 17, 18, 19, 20,
        19, 20, 21, 22, 23, 24,
        23, 24, 25, 26, 27, 28,
        27, 28, 29, 30, 31,  0
    ]

    # Ensure the input block is 32 bits
    if len(block) != 4:
        raise ValueError("Input block must be 32 bits")

    expanded_block = bytearray()
    for index in expansion_table:
        byte_index = (index - 1) // 8
        bit_index = (index - 1) % 8
        byte_value = block[byte_index]
        bit_value = (byte_value >> (7 - bit_index)) & 0x01
        if len(expanded_block) < (index // 6) + 1:
            expanded_block.append(0)
        bit_position = (5 - (index - 1) % 6) * 8 + (7 - bit_index)
        expanded_block[-1] |= (bit_value << bit_position) & 0xFF
    return expanded_block[:6]











#Define the function to perform recontrucction of the block
def combine_blocks(left_block, right_block):
    """Combine left and right blocks into a single block."""
    return left_block + right_block


#Define a function to do the XOR operation between two bytearrays
def xor_bytes(bytes1, bytes2):
    """
    Performs XOR operation between two bytearrays of equal length
    """
    if len(bytes1) != len(bytes2):
        raise ValueError("Bytearrays must have equal length")
    result = bytearray(len(bytes1))
    for i in range(len(bytes1)):
        result[i] = bytes1[i] ^ bytes2[i]
    return result



#Define the function to perform permutation for the Feistel function

def feistel_function(right_block, subkey):

    

# Define the S-box 1 (6 bits -> 4 bits)
    s_box_1 = [
    [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
    [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
    [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
    [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
]

# Define the S-box 2 (6 bits -> 4 bits)
    s_box_2 = [
    [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
    [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
    [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
    [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]
]

# Define the S-box 3 (6 bits -> 4 bits)
    s_box_3 = [
    [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
    [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
    [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
    [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]
]

# Define the S-box 4 (6 bits -> 4 bits)
    s_box_4 = [
    [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
    [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
    [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
    [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]
]

# Define the S-box 5 (6 bits -> 4 bits)
    s_box_5 = [
    [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
    [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
    [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
    [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]
    ]

# Define the S-box 6 (6 bits -> 4 bits)
    s_box_6 = [
    [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
    [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
    [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
    [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]
]

# Define the S-box 7 (6 bits -> 4 bits)
    s_box_7 = [
    [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
    [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
    [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
    [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]
]

# Define the S-box 7 (6 bits -> 4 bits)
    s_box_8 = [
    [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
    [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
    [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
    [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
]

    s_boxes = [s_box_1, s_box_2, s_box_3, s_box_4, s_box_5, s_box_6, s_box_7, s_box_8]


    if len(right_block) == 4:
        print("Block is 32 bits.")
        
    else:
        print("Block is not 32 bits.")


    expanded_block = expansion_permutation(bytearray(right_block))
# Check if the block is 32 bits
    if len(expanded_block) == 4:
        print("Block is 32 bits.")
        
    else:
        print("Block is not 32 bits.")

# XOR the expanded block with the subkey
    print(len(expanded_block), len(subkey))
    xored_block = xor_bytes(bytearray(expanded_block), bytearray(subkey))


    s_boxed_output=s_box_permutation(xored_block, s_boxes)


    p_boxed_permuted=p_box_permutation(s_boxed_output)



    return p_boxed_permuted
    


def s_box_permutation(input, s_boxes):
    output = bytearray()
    for i in range(4):  # Loop 4 times for a 6-byte input to get a 4-byte output
        s_box_byte = input[i*6:(i+1)*6]
        while len(s_box_byte) < 6:
            s_box_byte = b'\x00' + s_box_byte
        s_box_row = ((s_box_byte[0] & 0b100000) >> 4) | (s_box_byte[5] & 0b000001)
        s_box_col = (s_box_byte[1] & 0b11110) >> 1
        s_box_val = s_boxes[i][s_box_row][s_box_col]
        output.append(s_box_val >> 4)  # Append only the first 4 bits of s_box_val
    return output









#Define a function that removes the padding from the plaintext after decryption
def remove_padding(plaintext):
    """
    Removes PKCS#7 padding from the given plaintext.

    Args:
    plaintext (bytearray): The padded plaintext.

    Returns:
    bytearray: The unpadded plaintext.
    """

    # Get the padding value from the last byte of the plaintext
    padding_value = plaintext[-1]

    # Check if the padding value is valid
    if padding_value < 1 or padding_value > 8:
        raise ValueError("Invalid padding value.")

    # Check if the padding bytes are valid
    padding_bytes = plaintext[-padding_value:]
    for byte in padding_bytes:
        if byte != padding_value:
            raise ValueError("Invalid padding bytes.")

    # Remove the padding bytes from the plaintext
    unpadded_plaintext = plaintext[:-padding_value]

    return unpadded_plaintext






# Define a function that splits the data into chunks
def split_bits(data, block_size, chunk_size):
    if block_size % chunk_size != 0:
        raise ValueError("Block size must be a multiple of chunk size.")

    half_block_size = block_size // 2
    left_half = data[:half_block_size]
    right_half = data[half_block_size:]

    left_chunks = []
    for i in range(0, half_block_size, chunk_size):
        chunk = left_half[i:i+chunk_size]
        left_chunks.append(bytearray(chunk))

    right_chunks = []
    for i in range(0, half_block_size, chunk_size):
        chunk = right_half[i:i+chunk_size]
        right_chunks.append(bytearray(chunk))

    return left_chunks, right_chunks





#Define a function that performs the key schedule for k1,k2,or k3
def key_schedule(master_key, des_type=1):


    # Permutation table for the key shift
    shift_table = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]

    # Check if the DES type is valid
    if des_type not in [1, 2, 3]:
        print("Invalid DES type.")
        return None

    # Generate the initial key permutation
    pc1_perm = pc1_permutation(master_key)

    # Split the initial key into left and right halves
    left_half, right_half = split_block(pc1_perm)

    # Initialize the subkeys list
    subkeys = []

    # Determine the number of iterations and the shift table based on the DES type
    if des_type == 1:
        iterations = 16
        shift_table_type = shift_table
    elif des_type == 2:
        iterations = 32
        shift_table_type = shift_table * 2
    elif des_type == 3:
        iterations = 48
        shift_table_type = shift_table * 3

    # Perform the key schedule
    for i in range(iterations):
        # Perform the key shift
        left_half_shifted = left_shift_bits(left_half, shift_table_type[i])
        right_half_shifted = left_shift_bits(right_half, shift_table_type[i])
        shifted_key = left_half_shifted + right_half_shifted

        # Perform the subkey permutation and append the subkey to the list
        subkey = pc2_permutation(shifted_key)
        subkey = bytearray(subkey)  # Convert subkey to bytearray

        # Append the subkey to the list
        subkeys.append(subkey)

        # Update the left and right halves
        left_half = left_half_shifted
        right_half = right_half_shifted
    if des_type == 1:
    # Single key case, no need to generate additional subkeys
        return subkeys

    elif des_type == 2:
    # Double key case, generate second subkey by shifting the first subkey by one bit to the left
        left_shifted_key = left_shift_bits(subkeys[0], 1)
        subkey2 = pc2_permutation(left_shifted_key)
        subkeys.append(bytearray(subkey2))  # Convert subkey to bytearray and append to the list
    
        return subkeys

    elif des_type == 3:
    # Triple key case, generate second and third subkeys by shifting the first subkey by two and three bits to the left, respectively
        left_shifted_key1 = left_shift_bits(subkeys[0], 2)
        subkey2 = pc2_permutation(left_shifted_key1)
        subkeys.append(bytearray(subkey2))  # Convert subkey to bytearray and append to the list
    
        left_shifted_key2 = left_shift_bits(left_shifted_key1, 1)
        subkey3 = pc2_permutation(left_shifted_key2)
        subkeys.append(bytearray(subkey3))  # Convert subkey to bytearray and append to the list
    
        return subkeys

    







# Define a function that gets inputs from the user
def get_des_inputs():
    # Get the type of DES from the user
    des_type = get_des_type()

    # Get the master key from the user
    master_key = generate_master_key(des_type)


    # Get the mode of operation from the user
    mode = get_mode()

    # Initialize the IV and counter to None
    iv = None
    counter = None

    # If the mode of operation is CBC or CTR, get the IV or counter from the user
    if mode in ['CBC', 'OFB', 'CFB']:
        iv = get_iv()
    elif mode == 'CTR':
        counter = get_counter()

    # Pack the inputs into a dictionary and return it
    inputs = {
        'master_key': master_key,
        'mode': mode,
        'iv': iv,
        'counter': counter,
        'des_type': des_type
    }

    return inputs



def xor_blocks(left_block, right_block):
    """
    Performs a bitwise XOR operation on each bit of the right block with each bit of the left block.
    """




    if len(left_block) != len(right_block):
        raise ValueError("Blocks must have the same length")

    # Convert the blocks to bytearrays
    left_bytes = bytearray(left_block)
    right_bytes = bytearray(right_block)

    # Perform the XOR operation on each byte
    result_bytes = bytearray()
    for i in range(len(left_bytes)):
        result_bytes.append(left_bytes[i] ^ right_bytes[i])

    return result_bytes





def encrypt_block(plaintext, subkeys, des_type):

    plaintext = initial_permutation(plaintext)



    # Split the block into left and right halves
    left_block, right_block = split_block(plaintext)

    # Iterate over the subkeys and perform the appropriate operations based on the DES type
    for i in range(des_type*16):
        # Save a copy of the right block for use later
        prev_right_block = right_block[:]

        # Calculate the new right block using the Feistel function and the current subkey
        right_block = feistel_function(right_block, subkeys[i])

        # XOR the new right block with the left block
        right_block = xor_blocks(left_block, right_block)

        # Set the left block to the previous right block
        left_block = prev_right_block[:]

    # Combine the left and right blocks and perform the final permutation
    plaintext = combine_blocks(left_block, right_block)
    plaintext = inverse_permutation(plaintext)

    return plaintext


def decrypt_block(ciphertext, subkeys, des_type):
    # Perform the initial permutation on the block
    ciphertext = initial_permutation(ciphertext)

    # Split the block into left and right halves
    left_block, right_block = split_block(ciphertext)

    # Iterate over the subkeys in reverse order and perform the appropriate operations based on the DES type
    for i in range(-(des_type*16), 0, 1):
        # Save a copy of the left block for use later
        prev_right_block = right_block

        # Calculate the new left block using the Feistel function and the current subkey
        right_block = feistel_function(right_block, subkeys[i])

        # XOR the new left block with the right block
        
        left_block = xor_blocks(left_block, right_block)

        # Set the right block to the previous left block
        right_block = prev_right_block

    # Combine the left and right blocks and perform the final permutation
    ciphertext = combine_blocks(left_block, right_block)
    ciphertext = inverse_permutation(ciphertext)

    return ciphertext




def pad_message(message, block_size):
    """
    Pads the given message with PKCS#7.

    Args:
    message (bytes): The message to pad.
    block_size (int): The block size in bytes.

    Returns:
    bytes: The padded message.
    """
    padding = block_size - len(message) % block_size
    return message + bytes([padding] * padding)




#Define the function that runs ctr mode for DES

def ctr_mode_des(ciphertext, master_key,counter,des_type):
    # Generate the subkeys from the master key
    subkeys = key_schedule(master_key,des_type)

    # Initialize the cipher text and keystream
    plaintext = b''
    keystream = b''

    # Iterate over the ciphertext in blocks
    for i in range(0, len(ciphertext), 16):
        # Get the current block and pad it if necessary
        ciphertext = ciphertext[i:i+16]
        if len(ciphertext) < 16:
            ciphertext = pad_message(ciphertext, 16)

        # Generate the keystream for the current block
        encrypted_counter = encrypt_block(counter, subkeys)
        keystream = encrypted_counter

        # XOR the current block with the keystream
        plaintext += xor_blocks(ciphertext, keystream)

        # Increment the counter for the next block
        counter = increment_counter(counter)

    return plaintext


#des(ciphertext, master_key, mode, iv, counter,des_type)


def des(data, master_key, mode, iv=None, counter=None, encrypt=True, des_type=1):
    # Convert data to bytes if it is a string
    if isinstance(data, str):
        data = data.encode()

    # Convert data to bytearray
    data = bytearray(data)

    # Generate the subkeys from the master key
    subkeys = key_schedule(master_key, des_type)

    # Determine the block size based on the mode of operation
    if mode in ['ECB', 'CBC', 'CFB', 'OFB']:
        block_size = 8
    elif mode == 'CTR':
        block_size = 16

    # Initialize the result and previous block
    result = bytearray()
    prev_block = iv if iv is not None else bytearray(b'\x00' * block_size)

    # Iterate over the data in blocks
    for i in range(0, len(data), block_size):
        # Get the current block and XOR it with the previous block or IV
        block = data[i:i+block_size]

        # Check if the block is 32 bits
        if len(block) == 4:
            print("Block is 32 bits. This is the beginning of the des function")
        else:
            print("Block is not 32 bits. This is the beginning of the des function")
        if mode in ['CBC', 'CFB', 'OFB']:
            block = xor_blocks(block, prev_block)

        # Encrypt or decrypt the current block with the subkeys
        if encrypt:
            if mode == 'ECB':
                block = encrypt_block(block, subkeys, des_type)
            elif mode in ['CBC', 'OFB']:
                encrypted_block = encrypt_block(block, subkeys, des_type)
                block = xor_blocks(block, encrypted_block)
            elif mode == 'CFB':
                encrypted_block = encrypt_block(prev_block, subkeys, des_type)[:len(block)]
                block = xor_blocks(block, encrypted_block)
            elif mode == 'CTR':
                encrypted_counter = encrypt_block(counter, subkeys, des_type)
                keystream = encrypted_counter[len(block):]
                block = xor_blocks(block, keystream)
                counter = increment_counter(counter)
        else:
            if mode == 'ECB':
                block = decrypt_block(block, subkeys[::-1],des_type)
            elif mode in ['CBC', 'OFB']:
                decrypted_block = decrypt_block(block, subkeys[::-1])
                block = xor_blocks(decrypted_block, prev_block)
            elif mode == 'CFB':
                encrypted_block = encrypt_block(prev_block, subkeys, des_type)[:len(block)]
                block = xor_blocks(block, encrypted_block)
            elif mode == 'CTR':
                encrypted_counter = encrypt_block(counter, subkeys, des_type)
                keystream = encrypted_counter[len(block):]
                block = xor_blocks(block, keystream)
                counter = increment_counter(counter)

        # Update the result and previous block
        result += block
        prev_block = block

    return result





# Define a function that runs the DES algorithm
def run_des():
    while True:
        # Get the user's choice
        choice = input("Do you want to encrypt or decrypt a message? Press 'q' to quit. ").lower()
        
        if choice == 'q':
            print("Exiting program...")
            break
        
        if choice not in ['encrypt', 'decrypt']:
            print("Invalid choice. Please enter 'encrypt', 'decrypt', or 'q' to quit.")
            continue
        
        # Get all the inputs for the DES algorithm
        inputs = get_des_inputs()
        
        mode = inputs['mode']

        # Retrieve the inputs from the dictionary
        master_key = inputs['master_key']
        iv = inputs['iv']
        counter = inputs['counter']
        des_type = inputs['des_type']
        
    # Get the plaintext from the user
        if choice.lower() == 'encrypt':
            plaintext = get_padded_plaintext()
        elif choice.lower() == 'decrypt':
            ciphertext = get_ciphertext()
        else:
            print("Invalid choice. Please enter 'encrypt' or 'decrypt'.")

        # Determine the number of DES iterations to perform
        num_iterations = 1 if des_type == 1 else 2 if des_type == 2 else 3 if des_type == 3 else None
        
        if num_iterations is None:
            print("Invalid DES type entered.")
            return None
        
        # Run the DES algorithm for the appropriate number of iterations based on the mode of operation
        if choice == 'encrypt':
            ciphertext = plaintext
            for i in range(num_iterations):
                if mode in ['ECB', 'CBC', 'CFB', 'OFB']:
                    ciphertext = des(ciphertext, master_key, mode, iv, counter,des_type)
                elif mode == 'CTR':
                    ciphertext = ctr_mode_des(ciphertext, master_key, mode, iv, counter,des_type)
            
            # Print the encrypted message
            print("Encrypted message in hexadecimal:")
            print(ciphertext.hex())
        
        elif choice == 'decrypt':
            plaintext=ciphertext
            print(f"This is the current plaintext:{plaintext} it is {len(plaintext)}  byte long")
            for i in range(num_iterations):
                if mode in ['ECB', 'CBC', 'CFB', 'OFB']:
                    plaintext = des(plaintext, master_key, mode, iv, counter, encrypt=False, des_type=des_type)
                elif mode == 'CTR':
                    plaintext = ctr_mode_des(plaintext, master_key, mode, iv, counter, encrypt=False, des_type=des_type)
            
            # Print the decrypted message
            plaintext=remove_padding(plaintext)
            print("Decrypted message:")
            print(plaintext.decode('ascii'))
            
        # Ask the user if they want to continue
        while True:
            response = input("Do you want to continue? Press 'y' for yes, 'n' to return to the menu, or 'q' to quit. ").lower()
            if response == 'y':
                break
            elif response == 'n':
                return
            elif response == 'q':
                print("Exiting program...")
                exit() 
            else:
                print("Invalid response. Please enter 'y', 'n', or 'q'.")





def main():

    #Call the menu function
    menu()



    # menu()




if __name__ == "__main__":
    main()